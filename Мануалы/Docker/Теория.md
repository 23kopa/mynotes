### 1. **Docker**:

Docker — это платформа для создания, распространения и запуска приложений в контейнерах. Контейнеры позволяют запускать приложения в изолированном окружении, независимо от того, где они запускаются (например, на разных операционных системах или в разных машинах). Это помогает избавиться от проблем с зависимостями и различиями в конфигурациях систем.

Когда ты запускаешь команду `docker build` или `docker-compose up`, ты фактически создаешь контейнер для приложения, которое будет работать в этом изолированном окружении. Он упаковывает все зависимости и сам код в контейнер, обеспечивая воспроизводимость и изоляцию.
### 2. **Dockerfile**:

`Dockerfile` — это текстовый файл, который содержит инструкции для создания Docker-образа. Ты прописываешь все шаги, которые должны быть выполнены, чтобы создать этот образ. Например, как установить операционную систему, какие пакеты и библиотеки нужно установить, какие файлы скопировать и какие команды выполнить.
### 3. **docker-compose.yml**:

`docker-compose.yml` — это файл конфигурации для Docker Compose, который позволяет запускать несколько контейнеров (и их сервисы) с помощью одной команды. Он помогает описать, как должны взаимодействовать различные контейнеры и какие параметры они должны использовать.

---
### **Образ (Image)**

- Это **шаблон** (как ISO-файл для ОС), из которого создаются контейнеры.
- Он **неизменяемый** и содержит всё необходимое: код приложения, зависимости, среду выполнения.
- Образ можно **скачать**, **создать** или **запушить** в реестр (`Docker Hub` и другие).

```
docker pull node:16
```

### **Контейнер (Container)**

- Это **запущенный экземпляр образа**.
- Он создается из образа и работает как **изолированное приложение**.
- Можно создавать **много контейнеров** из одного образа.

```
docker run -it node:16 bash
```

### ❓ **Так что внутри чего?**

✔ **Образ** → используется для создания **контейнера**.  
✔ **Контейнер** создается **из образа** и запускает приложение.  
❌ **Контейнер НЕ содержит образы**.

- Когда ты запускаешь контейнер, Docker использует **образ** как шаблон для создания контейнера. Контейнер запускается и выполняется из этого образа.
- Если контейнер использует другие сервисы, например, базы данных, они могут быть отдельными контейнерами, работающими параллельно. В этом случае все контейнеры могут использовать образы, которые обеспечивают разные части инфраструктуры.
---
### Пример:

1. У тебя есть образ `node:16` (для приложения).
2. Ты создаешь новый образ, добавляя в него свое приложение.
3. Запускаешь контейнер из этого нового образа.
4. В другом контейнере может быть, например, база данных `postgres`, которая тоже использ> Просто вводи эти команды по порядку и смотри чтобы при Ctrl+V была та же команда

Зайди в консоль и лучше зайди от root, чтобы постоянно команду sudo не писать, но вообще пох, как те удобнее
```sh
sudo su
# Потом введи пароль
```
***
## 1. Установи пакеты на Linux.
```sh
sudo apt update
sudo apt install python3-venv wget
```

***
## 2. Установи Google Chrome (обязательно).

```sh
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
```

```sh
sudo apt-get install fonts-liberation
```

```sh
sudo dpkg -i google-chrome-stable_current_amd64.deb
```
***
## 3. Установи ChromeDriver (обязательно).
```sh
wget  https://storage.googleapis.com/chrome-for-testing-public/133.0.6943.98/linux64/chromedriver-linux64.zip # Пиши эту команду в той папке где хочешь чтобы лежал архив
```

```sh
unzip chromedriver-linux64.zip # Очевидно разархивация)))0)
```

```sh
cd chromedriver-linux64 # Переход в папку где лежит драйвер
```

```sh
sudo mv chromedriver /usr/local/bin/ # Перенос драйвера в bin (шоб запускать)
```

```sh
sudo chmod +x /usr/local/bin/chromedriver # Установка прав на исполнение 
```
***
```sh
google-chrome --version
chromedriver --version
```

```sh
# Они должны быть одних версий
Google Chrome 133.0.6943.98 
ChromeDriver 133.0.6943.98
```
***
## 4. Создай директорию где будешь хранить парсер.
```sh
mkdir Parser # Создай директорию
cd Parser # Перейди туда
```

> Смотри чтобы путь у тебя был примерно такой:
> `root@vbox:/home/user23/Parser#`

***
## 5. Запуск парсера.

Перенеси мой файл в папку Parser и напиши:
```sh
chmod +x parser_milf.py # Выдача файлу прав на исполнение
```

Чтобы запустить напиши:
```
./parser_milf.py
```
ует свой образ.

Контейнеры могут взаимодействовать между собой через сеть, но один контейнер не содержит внутри другой. Контейнеры **изолированы** друг от друга.

---
### **Итог:**

- **Образ** может использовать другой образ (например, базовый образ).
- **Контейнер** — это запущенный экземпляр образа, и он не может содержать другие контейнеры внутри себя.
- В одном проекте может быть несколько контейнеров, каждый из которых использует свой образ (или общие образы).

---

Образы. Общее:
```sh
# Проверка образов
docker images
```

```sh
# Удаление <none> образов
docker image prune -f
```

```sh
# Удаление образов неиспользуемых контейнерами
docker image prune -a -f
```

```sh
# Удаление образа
docker rmi IMAGE_ID
```

Контейнеры через образы:
```sh
# Запуск билда
docker-compose up --build
```

```sh
# Пересборка
docker-compose up --build -d
```

```sh
# Пересборка одного контейнера
docker-compose up -d --build nextcloud
```

```sh
# Удаление всех контейнеров
docker-compose down
```

```sh
# Остановка контейнера
docker stop game_game_1
```

Контейнеры:
```sh
# Проверка запущенных контейнеров
docker ps
```

```sh
# Какие контейнеры использую образы
docker ps -a
```

```sh
# Создание нового одиночного контейнера
docker run -it parser bash
```

```sh
# Подключение к контейнеру
docker exec -it game_game_1 bash
```

Данные:
```sh
docker volume ls
```

```sh
docker volume prune
```

```sh
docker volume rm nextcloud_db_data
```

```sh
# Очистка кеша
docker builder prune -f
```

```sh
# Удаление старых остановленных контейнеров
docker container prune -f
```

```sh
# Удаление образов без контейнеров 
docker image prune -a -f
```

